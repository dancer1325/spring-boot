[[features.external-config]]
= Externalized Configuration

* == configuration -- can be -- externalized
* allows
    ** sample aplication code | different environments
* external configuration sources
    ** .properties,
    ** .yaml,
    ** environment variables,
    ** CL arguments
* Property values
    ** can be
        *** -- via `@Value` annotation -- injected directly into your beans
        *** -- accessed through -- Spring's `Environment` abstraction
        *** -- via `@ConfigurationProperties` -- xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties[bound to structured objects]
* 👁️ `PropertySource` order / later property sources -- can override -- values defined earlier 👁️
    ** `SpringApplication.setDefaultProperties` -- default properties --
    ** `@PropertySource` annotations | `@Configuration` classes
        *** {url-spring-framework-javadoc}/org/springframework/context/annotation/PropertySource.html[Check]
        *** Once the application context has been refreshed (⚠️ & NOT before ⚠️) -> are added to the `Environment`
            **** -> 👁️ TOO late to configure certain properties 👁️ -- _Example:_  `+logging.*+` and `+spring.main.*+`  --
    ** config data
        *** order
            **** `application.properties` and `application.yaml` / packaged inside your jar
                ***** xref:features/external-config.adoc#features.external-config.files[Check application properties]
            **** `application-\{profile}.properties` and `application-\{profile}.yaml` / packaged inside your jar
                ***** xref:features/external-config.adoc#features.external-config.files.profile-specific[Check profile-specific application properties]
            **** `application.properties` and `application.yaml` / outside your packaged jar
                ***** xref:features/external-config.adoc#features.external-config.files[Check application properties]
            **** `application-\{profile}.properties` and `application-\{profile}.yaml` / outside your packaged jar
                ***** xref:features/external-config.adoc#features.external-config.files.profile-specific[Check profile-specific application properties]
            **** if you have both `.properties` and YAML format | same location ->  `.properties` takes precedence
        *** recommendations
            **** Choose 1! format (`.properties` OR `.yaml`) | your entire application
    ** `RandomValuePropertySource` / properties ONLY in `+random.*+`
    ** OS environment variables
        *** most operating systems disallow period-separated key names (__Example:__ `spring.config.name`) -> use underscores instead (__Example:__ SPRING_CONFIG_NAME)
            **** Check xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables[]
    ** Java System properties -- _Example:_ `System.getProperties()` --
    ** JNDI attributes from `java:comp/env`
        *** requirement
            **** application runs in a servlet container or application server
    ** `ServletContext` init parameters
        *** requirement
            **** application runs in a servlet container or application server
    ** `ServletConfig` init parameters
    ** Properties from `SPRING_APPLICATION_JSON`
        *** == inline JSON / -- embedded in -- environment variable or system property
    ** CL arguments
    ** `properties` attribute | tests
        *** Check
            **** xref:api:java/org/springframework/boot/test/context/SpringBootTest.html[`@SpringBootTest`]
            **** xref:testing/spring-boot-applications.adoc#testing.spring-boot-applications.autoconfigured-tests[test annotations for testing a particular slice of your application]
    ** {url-spring-framework-javadoc}/org/springframework/test/context/DynamicPropertySource.html[`@DynamicPropertySource`] annotations | tests
    ** {url-spring-framework-javadoc}/org/springframework/test/context/TestPropertySource.html[`@TestPropertySource`] annotations | tests
    ** if devtools is active -> xref:using/devtools.adoc#using.devtools.globalsettings[Devtools global settings properties] in `$HOME/.config/spring-boot` directory
* _Example:_
    ** Let's a `@Component` / uses a `name` property

    include-code::MyBean[]

        *** it could be overriden with
            **** application classpath ( -- _Example:_ inside jar) / `application.properties` setting a value for `name`
            **** if you run a new environment, providing an `application.properties`  outside of your jar
            **** launch a specific CL (-- _Example:_ `java -jar app.jar --name="Spring"` --)
* endpoints `/env` and `/configprops`
    ** allows
        *** determining the value of a property
    ** Check xref:actuator/endpoints.adoc[Production ready features]


[[features.external-config.command-line-args]]
== Accessing Command Line Properties
* CL's arguments -- are by `SpringApplication` --
    ** converted to a `property`
    ** added them to Spring `Environment`
        *** if you want to disable this behavior -> `SpringApplication.setAddCommandLineProperties(false)`


[[features.external-config.application-json]]
== JSON Application Properties

* == block of properties -- is encoded into -- single JSON structure
* vs OS environment variables or Java System properties
    ** NO restrictions in some property names
* if your application starts ->  any `spring.application.json` or `SPRING_APPLICATION_JSON` properties --
    ** are --
        *** parsed -- to the `Environment`
        *** added -- to the `Environment`
    ** _Example:_
        *** `SPRING_APPLICATION_JSON` property -- can be supplied on CL in a UN{asterisk}X shell as -- environment variable

    [source,shell]
    ----
    $ SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
    ----

            **** `my.name=test` is added in the Spring `Environment`
        *** supply the JSON -- as a system property:

    [source,shell]
    ----
    $ java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
    ----

        *** supply the JSON -- as CL's argument:

    [source,shell]
    ----
    $ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
    ----

* if you are deploying to classic Application Server ->  you could use a JNDI variable / named `java:comp/env/spring.application.json`
* if JSON / `null` value -> 👁️ properties from lower order property sources are NOT override 👁️
    ** Reason: 🧠 `null` values from the JSON -- are added to the -- resulting property source, BUT `PropertySourcesPropertyResolver` treats `null` properties == missing values🧠


[[features.external-config.files]]
== External Application Properties

*  When your application starts -> Spring Boot automatically finds and loads  `application.properties` and `application.yaml` files
    ** from the 👁️following locations / lower items in the next list override earlier ones👁️
        *** From the classpath
            **** classpath root
            **** classpath `/config` package
        *** From the current directory
            **** current directory
            **** current directory's `config/` subdirectory
            **** `config/` subdirectory's immediate child directories
    ** are added as `PropertySources` to the Spring `Environment`
    ** if you do not like `application` as the configuration file name -> you can switch via `spring.config.name=anotherFileName`
        *** _Example:_ look for `myproject.properties` and `myproject.yaml` files

        [source,shell]
        ----
        $ java -jar myproject.jar --spring.config.name=myproject
        ----

    ** if you want to refer to another location -> specify `spring.config.location=anotherLocation1,anotherLocation2,...`
        *** ⚠️ if you configure it -> replace the default locations ⚠️
            **** _Example:_ if `spring.config.location=optional:classpath:/custom-config/,optional:file:./custom-config/` -> the complete set of locations is


                optional:classpath:custom-config/
                optional:file:./custom-config/


        *** if the xref:features/external-config.adoc#features.external-config.files.optional-prefix[locations are optional] & you do NOT mind if they do NOT exist -> Use the prefix `optional:`
        *** if it contains directories -> should end in `/`
        *** at runtime, before being loaded, these -- will be appended with -- names generated from `spring.config.name`
        *** 👁️ later items added can override the values of earlier ones 👁️
            **** Reason: 🧠 Locations are processed in the order that they are added 🧠
        *** files specified here are imported directly
        *** _Example:_

        [source,shell]
        ----
        $ java -jar myproject.jar --spring.config.location=\
            optional:classpath:/default.properties,\
            optional:classpath:/override.properties
        ----

        *** 👁️(Both directory and file location) expanded to check for xref:features/external-config.adoc#features.external-config.files.profile-specific[profile-specific files] 👁️
            **** _Example:_ if you have a `spring.config.location=classpath:myconfig.properties` ->  `classpath:myconfig-<profile>.properties` files are loaded
    ** if you want to add additional locations, rather than replacing them, ->  `spring.config.additional-location`
        *** override those in the default locations
        *** _Example:_ if `spring.config.additional-location=optional:classpath:/custom-config/,optional:file:./custom-config/` -> the complete set of locations is

            optional:classpath:/;optional:classpath:/config/
            optional:file:./;optional:file:./config/;optional:file:./config/*/
            optional:classpath:custom-config/
            optional:file:./custom-config/

* `spring.config.name`, `spring.config.location`, and `spring.config.additional-location`
    ** must be 👁️ defined as an environment property (-- __Example:__ OS environment variable, system property, or CL argument --) 👁️
        *** Reason: 🧠 are used very early -- to determine -- which files have to be loaded 🧠
    ** allows
        *** values in `application.properties` OR others / indicated in `spring.config.name` | default locations -- can be overridden 👁️ at runtime 👁️ with -> different file | custom locations
        *** selectively overriding values / placed in another files

[[features.external-config.files.location-groups]]
=== Location Groups

* := collection of locations / are all considered at the same level
    ** `;` is the delimiter of items in the same group -- `locationGroupItem1;locationGroupItem2;locationGroupItem3...` --
* allows
    ** providing further hints so that Spring Boot knows how they should be grouped
* uses
    ** you use complex location setup, and profile-specific configuration files
* _Example:_ Check in xref:features/external-config.adoc#features.external-config.files.profile-specific[]


[[features.external-config.files.optional-prefix]]
=== Optional Locations

* if a specified config data location does NOT exist
    ** ->
        *** Spring Boot will throw a `ConfigDataLocationNotFoundException` &
        *** your application will NOT start
    ** 👁️solution to skip it `spring.config.on-not-found=ignore` 👁️
        *** you can specify it via
            **** `SpringApplication.setDefaultProperties(...)` or
            **** system/environment variable
* `optional:locationToSpecify`
    ** := prefix
    ** uses
        *** for the environment variables
            **** `spring.config.location`
            **** `spring.config.additional-location`
            **** xref:features/external-config.adoc#features.external-config.files.importing[`spring.config.import`]
        *** NOT mind if it does NOT always exist
            **** _Example:_ if `spring.config.import=optional:file:./myconfig.properties` & `myconfig.properties` file is missing -> your application can start

[[features.external-config.files.wildcard-locations]]
=== Wildcard Locations

* := config file location / `{asterisk}` character for the last path segment
    ** when the config is loaded -> wildcards are expanded  -> immediate subdirectories are also checked
    ** 1! must be added
        *** `{asterisk}/` -- search locations / are directories
        *** `*/<filename>` -- search locations / are files
    ** are sorted alphabetically -- based on the -- absolute path of the file names
    ** 👁️ only work with external directories 👁️
        *** == NOT valid in a `classpath:` location
* uses
    ** environments / there are multiple sources of config properties -- _Example:_ Kubernetes --
        *** _Example:_ let's Redis configuration and MySQL configuration & you want to keep two pieces of configuration separate & both those are present in an `application.properties` file ->
            **** might result in `/config/redis/application.properties` + `/config/mysql/application.properties`
            **** with `config/*/` -> both files are processed
    ** with `spring.config.location` and `spring.config.additional-location` properties
* `config/*/` included by default by Spring Boot
    ** == ALL subdirectories of the `/config` outside of your jar -- will be -- searched


[[features.external-config.files.profile-specific]]
=== Profile Specific Files

* `spring.profiles.active=profile1,profile2,...`
    ** 👁️if NO profiles are explicitly activated -> `application-default` is considered 👁️
        *** := profile / contained by the `Environment`
* `application-\{profile}`
    ** naming convention
* if your application activates a profile (-- _Example:_ `prod` --) -> both are considered ( -- _Example:_ `application.yaml` and `application-prod.yaml` -- )
    ** 👁️BUT, profile-specific files always override the non-specific ones 👁️
    ** if several profiles are specified -> last-wins strategy (== last profile specific takes priority) | xref:features/external-config.adoc#features.external-config.files.location-groups[location group] level
        *** `spring.config.location=classpath:/cfg/,classpath:/ext/` overriding rules != `spring.config.location=classpath:/cfg/;classpath:/ext/` overriding rules
* characteristics
    ** -- are loaded
        *** from -- same locations as standard `application.properties`
        *** 1! time
            **** == if you have already directly xref:features/external-config.adoc#features.external-config.files.importing[imported] a profile specific property files -> NOT imported a 2 time
* _Example:_
    ** let's have `prod,live`, with the files

        /cfg
          application-live.properties
        /ext
          application-live.properties
          application-prod.properties

        *** if we have `spring.config.location=classpath:/cfg/,classpath:/ext/` -> we process all `/cfg` files before all `/ext` files:

            . /cfg/application-live.properties
            . /ext/application-prod.properties
            . /ext/application-live.properties

        *** if we have `spring.config.location=classpath:/cfg/;classpath:/ext/` -> we process `/cfg` and `/ext` at the same level == in the order

            . /ext/application-prod.properties
            . /cfg/application-live.properties
            . /ext/application-live.properties


[[features.external-config.files.importing]]
=== Importing Additional Data

* `spring.config.import=import1,import2,...`
* allows
    ** importing further config data
        *** in application properties
        *** from other locations
* characteristics
    ** as soon as they are discovered -> they are processed
        *** later imports take precedence -- _Example:_ import2 in the previous example takes precedence to import1 --
    ** -- are treated as -- 👁️additional documents / inserted immediately below the `...import` is declared 👁️
    ** ⚠️ although you declare to import several times -> it will be imported 1!  ⚠️
    ** 👁 order that an import is defined within the properties/yaml file does NOT matter 👁
        *** _Example:_ next '.properties' produce the same result

            [configprops%novalidate,yaml]
            ----
            spring:
              config:
                import: "my.properties" # Imported values here take precedence over the configured in this file, independently the order here
            my:
              property: "value"
            ----

            [configprops%novalidate,yaml]
            ----
            my:
              property: "value"
            spring:
              config:
                import: "my.properties" #  any `my-<profile>.properties` variants are imported
            ----

    ** 👁importedFile's values -- take precedence over -- fileWhichTriggersTheImport's values 👁
        *** _Example:_ Check the previous example
    ** 👁 xref:features/external-config.adoc#features.external-config.files.profile-specific[Profile-specific variants] are also considered for import 👁
        *** _Example:_ Check the previous example
    ** can be imported
        *** by default
            **** Java properties
                ***** '.properties'
                ***** '.yaml'
            **** xref:features/external-config.adoc#features.external-config.files.configtree[configuration trees]
        *** from different locations
            **** local
            **** one's / provided by pluggable API
                ***** _Example:_ external stores -- Consul, Apache ZooKeeper or Netflix Archaius --
            **** customizable
                ***** Check `ConfigDataLocationResolver` and `ConfigDataLoader` classes | `org.springframework.boot.context.config` package
* _Example:_
    ** Let's have in your classpath `application.properties` file

    [configprops,yaml]
    ----
    spring:
      application:
        name: "myapp"
      config:
        import: "optional:file:./dev.properties"
    ----

        *** `dev.properties` file in current directory (if such a file exists)
            **** is imported
            **** `dev.properties` 's values take precedence over the file that triggered the import (== `application.properties` in this case)

[[features.external-config.files.importing-extensionless]]
=== Importing Extensionless Files

* uses
    ** some cloud platforms / can NOT add a file extension to volume mounted files
* how to address it?
    ** put an extension hint in square brackets
        *** _Example:_ Let's `/etc/config/myconfig` file / you wish to import as yaml

            [configprops,yaml]
            ----
            spring:
              config:
                import: "file:/etc/config/myconfig[.yaml]"
            ----

[[features.external-config.files.configtree]]
=== Using Configuration Trees

* options to provide configurations | many cloud platforms
    ** environment variables
        *** NOT recommended for secrets
    ** mounted data volumes
        *** common volume mount patterns
            **** 1! file / contains a complete set of properties
                ***** -- can be got via –– `spring.config.import` Check xref:features/external-config.adoc#features.external-config.files.importing[above]
            **** 👁 >1 files / written to a directory tree 👁
                ***** with
                    ****** filename and foldername -- '`key`'
                    ****** contents -- '`value`'
                ***** -- can be got via –– `configtree:`
        *** _Example:_ In Kubernetes, https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod[`Secrets`] and https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap[`ConfigMaps`]

* `configtree`
    ** := prefix to specify configuration trees /
        *** -- can be accessed from -- `Environment` as usual way
        *** values -- can be bound to -- `String` and `byte[]` types
    ** _Example:_    Let's imagine, Kubernetes has mounted the following volume

    [source]
    ----
    etc/
      config/
        myapp.username  # it's a file
        myapp/
          username  # content could be a config value
          password  # content could be a secret
    ----

        **** add the following to your `application.properties` or `application.yaml`

        [configprops,yaml]
        ----
        spring:
          config:
            import: "optional:configtree:/etc/config/"
        ----

        **** `spring.config.import=optional:configtree:/etc/config/myapp` -- allows accessing to -- properties as
            ***** `username`
            ***** `password`
        **** Filenames / contain '.' -> correctly mapped
            ***** _Example:_ 'myapp.username' -- would result in -- `myapp.username` property in the `Environment`
    ** if you have >1 config trees / same parent folder -> use `configtree:../*/`
        *** Reason: 🧠 ALL immediate children -- are imported as -- config trees 🧠
        *** If you do NOT use `/*/` -- based on folderName and fileName -> try to form properties
        *** _Example:_ let's have

            [source]
            ----
            etc/
              config/
                dbconfig/
                  db/
                    username
                    password
                mqconfig/
                  mq/
                    username
                    password
            ----

            **** use `configtree:/etc/config/*/`

            [configprops,yaml]
            ----
            spring:
              config:
                import: "optional:configtree:/etc/config/*/"
            ----

            **** it adds the properties / names `db.username`, `db.password`, `mq.username` and `mq.password`
        *** 👁directories are sorted alphabetically 👁
            **** xref:features/external-config.adoc#features.external-config.files.importing[Check here]
            **** if you need a different order -> each location -- must be listed as -- separate import
    ** uses
        *** >1 files / written to a directory tree | cloud platform
        *** Docker secrets
            **** if a Docker swarm service / -- is granted access to -- a secret -> secret gets mounted into the container
                ***** _Example:_ secret named `db.password` / mounted at location `/run/secrets/` -> you can make it available to the Spring environment via

                [configprops,yaml]
                ----
                spring:
                  config:
                    import: "optional:configtree:/run/secrets/"
                ----


[[features.external-config.files.property-placeholders]]
=== Property Placeholders

* TODO:
The values in `application.properties` and `application.yaml` are filtered through the existing `Environment` when they are used, so you can refer back to previously defined values (for example, from System properties or environment variables).
The standard `$\{name}` property-placeholder syntax can be used anywhere within a value.
Property placeholders can also specify a default value using a `:` to separate the default value from the property name, for example `${name:default}`.

The use of placeholders with and without defaults is shown in the following example:

[configprops%novalidate,yaml]
----
app:
  name: "MyApp"
  description: "${app.name} is a Spring Boot application written by ${username:Unknown}"
----

Assuming that the `username` property has not been set elsewhere, `app.description` will have the value `MyApp is a Spring Boot application written by Unknown`.

[NOTE]
====
You should always refer to property names in the placeholder using their canonical form (kebab-case using only lowercase letters).
This will allow Spring Boot to use the same logic as it does when xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding[relaxed binding] `@ConfigurationProperties`.

For example, `${demo.item-price}` will pick up `demo.item-price` and `demo.itemPrice` forms from the `application.properties` file, as well as `DEMO_ITEMPRICE` from the system environment.
If you used `${demo.itemPrice}` instead, `demo.item-price` and `DEMO_ITEMPRICE` would not be considered.
====

TIP: You can also use this technique to create "`short`" variants of existing Spring Boot properties.
See the xref:how-to:properties-and-configuration.adoc#howto.properties-and-configuration.short-command-line-arguments[] section in "`How-to Guides`" for details.



[[features.external-config.files.multi-document]]
=== Working With Multi-Document Files

Spring Boot allows you to split a single physical file into multiple logical documents which are each added independently.
Documents are processed in order, from top to bottom.
Later documents can override the properties defined in earlier ones.

For `application.yaml` files, the standard YAML multi-document syntax is used.
Three consecutive hyphens represent the end of one document, and the start of the next.

For example, the following file has two logical documents:

[source,yaml]
----
spring:
  application:
    name: "MyApp"
---
spring:
  application:
    name: "MyCloudApp"
  config:
    activate:
      on-cloud-platform: "kubernetes"
----

For `application.properties` files a special `#---` or `!---` comment is used to mark the document splits:

[source,properties]
----
spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
----

NOTE: Property file separators must not have any leading whitespace and must have exactly three hyphen characters.
The lines immediately before and after the separator must not be same comment prefix.

TIP: Multi-document property files are often used in conjunction with activation properties such as `spring.config.activate.on-profile`.
See the xref:features/external-config.adoc#features.external-config.files.activation-properties[next section] for details.

WARNING: Multi-document property files cannot be loaded by using the `@PropertySource` or `@TestPropertySource` annotations.



[[features.external-config.files.activation-properties]]
=== Activation Properties

It is sometimes useful to only activate a given set of properties when certain conditions are met.
For example, you might have properties that are only relevant when a specific profile is active.

You can conditionally activate a properties document using `spring.config.activate.*`.

The following activation properties are available:

.activation properties
[cols="1,4"]
|===
| Property | Note

| `on-profile`
| A profile expression that must match for the document to be active.

| `on-cloud-platform`
| The `CloudPlatform` that must be detected for the document to be active.
|===

For example, the following specifies that the second document is only active when running on Kubernetes, and only when either the "`prod`" or "`staging`" profiles are active:

[configprops%novalidate,yaml]
----
myprop:
  "always-set"
---
spring:
  config:
    activate:
      on-cloud-platform: "kubernetes"
      on-profile: "prod | staging"
myotherprop: "sometimes-set"
----



[[features.external-config.encrypting]]
== Encrypting Properties

Spring Boot does not provide any built-in support for encrypting property values, however, it does provide the hook points necessary to modify values contained in the Spring `Environment`.
The `EnvironmentPostProcessor` interface allows you to manipulate the `Environment` before the application starts.
See xref:how-to:application.adoc#howto.application.customize-the-environment-or-application-context[] for details.

If you need a secure way to store credentials and passwords, the https://cloud.spring.io/spring-cloud-vault/[Spring Cloud Vault] project provides support for storing externalized configuration in https://www.vaultproject.io/[HashiCorp Vault].



[[features.external-config.yaml]]
== Working With YAML

https://yaml.org[YAML] is a superset of JSON and, as such, is a convenient format for specifying hierarchical configuration data.
The `SpringApplication` class automatically supports YAML as an alternative to properties whenever you have the https://github.com/snakeyaml/snakeyaml[SnakeYAML] library on your classpath.

NOTE: If you use starters, SnakeYAML is automatically provided by `spring-boot-starter`.



[[features.external-config.yaml.mapping-to-properties]]
=== Mapping YAML to Properties

YAML documents need to be converted from their hierarchical format to a flat structure that can be used with the Spring `Environment`.
For example, consider the following YAML document:

[source,yaml]
----
environments:
  dev:
    url: "https://dev.example.com"
    name: "Developer Setup"
  prod:
    url: "https://another.example.com"
    name: "My Cool App"
----

In order to access these properties from the `Environment`, they would be flattened as follows:

[source,properties]
----
environments.dev.url=https://dev.example.com
environments.dev.name=Developer Setup
environments.prod.url=https://another.example.com
environments.prod.name=My Cool App
----

Likewise, YAML lists also need to be flattened.
They are represented as property keys with `[index]` dereferencers.
For example, consider the following YAML:

[source,yaml]
----
 my:
  servers:
  - "dev.example.com"
  - "another.example.com"
----

The preceding example would be transformed into these properties:

[source,properties]
----
my.servers[0]=dev.example.com
my.servers[1]=another.example.com
----

TIP: Properties that use the `[index]` notation can be bound to Java `List` or `Set` objects using Spring Boot's `Binder` class.
For more details see the xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties[] section below.

WARNING: YAML files cannot be loaded by using the `@PropertySource` or `@TestPropertySource` annotations.
So, in the case that you need to load values that way, you need to use a properties file.



[[features.external-config.yaml.directly-loading]]
=== Directly Loading YAML

Spring Framework provides two convenient classes that can be used to load YAML documents.
The `YamlPropertiesFactoryBean` loads YAML as `Properties` and the `YamlMapFactoryBean` loads YAML as a `Map`.

You can also use the `YamlPropertySourceLoader` class if you want to load YAML as a Spring `PropertySource`.



[[features.external-config.random-values]]
== Configuring Random Values

The `RandomValuePropertySource` is useful for injecting random values (for example, into secrets or test cases).
It can produce integers, longs, uuids, or strings, as shown in the following example:

[configprops%novalidate,yaml]
----
my:
  secret: "${random.value}"
  number: "${random.int}"
  bignumber: "${random.long}"
  uuid: "${random.uuid}"
  number-less-than-ten: "${random.int(10)}"
  number-in-range: "${random.int[1024,65536]}"
----

The `+random.int*+` syntax is `OPEN value (,max) CLOSE` where the `OPEN,CLOSE` are any character and `value,max` are integers.
If `max` is provided, then `value` is the minimum value and `max` is the maximum value (exclusive).



[[features.external-config.system-environment]]
== Configuring System Environment Properties

Spring Boot supports setting a prefix for environment properties.
This is useful if the system environment is shared by multiple Spring Boot applications with different configuration requirements.
The prefix for system environment properties can be set directly on `SpringApplication`.

For example, if you set the prefix to `input`, a property such as `remote.timeout` will also be resolved as `input.remote.timeout` in the system environment.



[[features.external-config.typesafe-configuration-properties]]
== Type-safe Configuration Properties

* `@Value("$\{property}")`
    ** can cumbersome
        *** use cases
            **** working with multiple properties
            **** your data is hierarchical
* `@ConfigurationProperties`
    ** type-safe configuration properties
    ** alternative to previous one
    ** allows
        *** strongly typed beans
        *** validate the configuration
    ** xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.vs-value-annotation[`@Value` vs `@ConfigurationProperties`]


[[features.external-config.typesafe-configuration-properties.java-bean-binding]]
=== JavaBean Properties Binding

It is possible to bind a bean declaring standard JavaBean properties as shown in the following example:

include-code::MyProperties[]

The preceding POJO defines the following properties:

* `my.service.enabled`, with a value of `false` by default.
* `my.service.remote-address`, with a type that can be coerced from `String`.
* `my.service.security.username`, with a nested "security" object whose name is determined by the name of the property.
  In particular, the type is not used at all there and could have been `SecurityProperties`.
* `my.service.security.password`.
* `my.service.security.roles`, with a collection of `String` that defaults to `USER`.

NOTE: The properties that map to `@ConfigurationProperties` classes available in Spring Boot, which are configured through properties files, YAML files, environment variables, and other mechanisms, are public API but the accessors (getters/setters) of the class itself are not meant to be used directly.

[NOTE]
====
Such arrangement relies on a default empty constructor and getters and setters are usually mandatory, since binding is through standard Java Beans property descriptors, just like in Spring MVC.
A setter may be omitted in the following cases:

* Maps, as long as they are initialized, need a getter but not necessarily a setter, since they can be mutated by the binder.
* Collections and arrays can be accessed either through an index (typically with YAML) or by using a single comma-separated value (properties).
  In the latter case, a setter is mandatory.
  We recommend to always add a setter for such types.
  If you initialize a collection, make sure it is not immutable (as in the preceding example).
* If nested POJO properties are initialized (like the `Security` field in the preceding example), a setter is not required.
  If you want the binder to create the instance on the fly by using its default constructor, you need a setter.

Some people use Project Lombok to add getters and setters automatically.
Make sure that Lombok does not generate any particular constructor for such a type, as it is used automatically by the container to instantiate the object.

Finally, only standard Java Bean properties are considered and binding on static properties is not supported.
====



[[features.external-config.typesafe-configuration-properties.constructor-binding]]
=== Constructor Binding

* _Example:_ previous example / rewrite -- in an -- immutable fashion way

include-code::MyProperties[]

* allows
    ** binder -- finds a -- constructor / include wished bounded parameters
* ⚠️ if you have 1! parameterized constructor -> constructor binding -- automatically -- is done ⚠️
    ** ways to avoid this behavior
        *** `@Autowired` | constructor
        *** makes the constructor `private`
* if your class has multiple constructors -> `@ConstructorBinding` | constructor / -- is going to be used for -- constructor binding
* uses
    ** | records / has multiple constructors
        *** Reason: 🧠if there is 1! constructor -> NO need to use `@ConstructorBinding` 🧠
* Nested members of a constructor bound class (_Example:_ `Security` ) -- will also be bound through -- their constructor
* TODO:
Default values can be specified using `@DefaultValue` on constructor parameters and record components.
The conversion service will be applied to coerce the annotation's `String` value to the target type of a missing property.

Referring to the previous example, if no properties are bound to `Security`, the `MyProperties` instance will contain a `null` value for `security`.
To make it contain a non-null instance of `Security` even when no properties are bound to it (when using Kotlin, this will require the `username` and `password` parameters of `Security` to be declared as nullable as they do not have default values), use an empty `@DefaultValue` annotation:

include-code::nonnull/MyProperties[tag=*]

* requirements to use constructor binding
    ** | class
        *** `@EnableConfigurationProperties` OR
        *** configuration property scanning
    ** class -- must be compiled with -- `-parameters`
        *** done automatically, if you use
            **** Spring Boot's Gradle plugin or
            **** Maven `spring-boot-starter-parent`
* NOT possible to use
    ** | beans / -- created by -- regular Spring mechanisms (_Example:_ `@Component`, `@Bean` | methods or loaded -- by -- `@Import`)

NOTE: The use of `java.util.Optional` with `@ConfigurationProperties` is not recommended as it is primarily intended for use as a return type.
As such, it is not well-suited to configuration property injection.
For consistency with properties of other types, if you do declare an `Optional` property and it has no value, `null` rather than an empty `Optional` will be bound.



[[features.external-config.typesafe-configuration-properties.enabling-annotated-types]]
=== Enabling @ConfigurationProperties-annotated Types

Spring Boot provides infrastructure to bind `@ConfigurationProperties` types and register them as beans.
You can either enable configuration properties on a class-by-class basis or enable configuration property scanning that works in a similar manner to component scanning.

Sometimes, classes annotated with `@ConfigurationProperties` might not be suitable for scanning, for example, if you're developing your own auto-configuration or you want to enable them conditionally.
In these cases, specify the list of types to process using the `@EnableConfigurationProperties` annotation.
This can be done on any `@Configuration` class, as shown in the following example:

include-code::MyConfiguration[]
include-code::SomeProperties[]

To use configuration property scanning, add the `@ConfigurationPropertiesScan` annotation to your application.
Typically, it is added to the main application class that is annotated with `@SpringBootApplication` but it can be added to any `@Configuration` class.
By default, scanning will occur from the package of the class that declares the annotation.
If you want to define specific packages to scan, you can do so as shown in the following example:

include-code::MyApplication[]

[NOTE]
====
When the `@ConfigurationProperties` bean is registered using configuration property scanning or through `@EnableConfigurationProperties`, the bean has a conventional name: `<prefix>-<fqn>`, where `<prefix>` is the environment key prefix specified in the `@ConfigurationProperties` annotation and `<fqn>` is the fully qualified name of the bean.
If the annotation does not provide any prefix, only the fully qualified name of the bean is used.

Assuming that it is in the `com.example.app` package, the bean name of the `SomeProperties` example above is `some.properties-com.example.app.SomeProperties`.
====

We recommend that `@ConfigurationProperties` only deal with the environment and, in particular, does not inject other beans from the context.
For corner cases, setter injection can be used or any of the `*Aware` interfaces provided by the framework (such as `EnvironmentAware` if you need access to the `Environment`).
If you still want to inject other beans using the constructor, the configuration properties bean must be annotated with `@Component` and use JavaBean-based property binding.



[[features.external-config.typesafe-configuration-properties.using-annotated-types]]
=== Using @ConfigurationProperties-annotated Types

This style of configuration works particularly well with the `SpringApplication` external YAML configuration, as shown in the following example:

[source,yaml]
----
my:
  service:
    remote-address: 192.168.1.1
    security:
      username: "admin"
      roles:
      - "USER"
      - "ADMIN"
----

To work with `@ConfigurationProperties` beans, you can inject them in the same way as any other bean, as shown in the following example:

include-code::MyService[]

TIP: Using `@ConfigurationProperties` also lets you generate metadata files that can be used by IDEs to offer auto-completion for your own keys.
See the xref:specification:configuration-metadata/index.adoc[appendix] for details.



[[features.external-config.typesafe-configuration-properties.third-party-configuration]]
=== Third-party Configuration

As well as using `@ConfigurationProperties` to annotate a class, you can also use it on public `@Bean` methods.
Doing so can be particularly useful when you want to bind properties to third-party components that are outside of your control.

To configure a bean from the `Environment` properties, add `@ConfigurationProperties` to its bean registration, as shown in the following example:

include-code::ThirdPartyConfiguration[]

Any JavaBean property defined with the `another` prefix is mapped onto that `AnotherComponent` bean in manner similar to the preceding `SomeProperties` example.



[[features.external-config.typesafe-configuration-properties.relaxed-binding]]
=== Relaxed Binding

* relaxed rules / bind `Environment` properties -- to -- `@ConfigurationProperties` beans
    ** -> NOT need an exact match between the `Environment` property name -- & -- bean property name
    ** uses
        *** dash-separated environment properties
            **** _Example:_ `context-path` -- binds to -- `contextPath`
        *** capitalized environment properties
            **** _Example:_ `PORT` -- binds to -- `port`
* _Example:_

include-code::MyPersonProperties[]

.relaxed binding
[cols="1,4"]
|===
| Property | Note

| `my.main-project.person.first-name`
| Kebab case

recommended for `.properties` and YAML files

| `my.main-project.person.firstName`
| Standard camel case syntax

| `my.main-project.person.first_name`
| Underscore notation

alternative format for `.properties` and YAML files

| `MY_MAINPROJECT_PERSON_FIRSTNAME`
| Upper case format

recommended for system environment variables
|===

* `ConfigurationProperties(prefix="something-lowercase-and-kebabcase)`
    ** _Example:_ `my.main-project.person`

.relaxed binding rules / property source
[cols="2,4,4"]
|===
| Property Source | Simple | List

| Properties Files
| Camel case

kebab case

underscore notation
| Standard list syntax -- via -- `[]` or

comma-separated == `value1, value2, ...`

| YAML Files
| Camel case

kebab case

underscore notation
| Standard YAML list syntax -- via -- `[]` or

comma-separated values `value1, value2, ...`

| Environment Variables
| Upper case format / `_` as delimiter

check xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables[]
| Numeric values / surrounded by `_`

check  xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables[]

| System properties
| Camel case

kebab case

underscore notation
| Standard list syntax -- via -- `[]` or

comma-separated  == `value1, value2, ...`
|===


[[features.external-config.typesafe-configuration-properties.relaxed-binding.maps]]
==== Binding Maps

When binding to `Map` properties you may need to use a special bracket notation so that the original `key` value is preserved.
If the key is not surrounded by `[]`, any characters that are not alpha-numeric, `-` or `.` are removed.

For example, consider binding the following properties to a `Map<String,String>`:

[configprops%novalidate,yaml]
----
my:
  map:
    "[/key1]": "value1"
    "[/key2]": "value2"
    "/key3": "value3"
----

NOTE: For YAML files, the brackets need to be surrounded by quotes for the keys to be parsed properly.

The properties above will bind to a `Map` with `/key1`, `/key2` and `key3` as the keys in the map.
The slash has been removed from `key3` because it was not surrounded by square brackets.

When binding to scalar values, keys with `.` in them do not need to be surrounded by `[]`.
Scalar values include enums and all types in the `java.lang` package except for `Object`.
Binding `a.b=c` to `Map<String, String>` will preserve the `.` in the key and return a Map with the entry `{"a.b"="c"}`.
For any other types you need to use the bracket notation if your `key` contains a `.`.
For example, binding `a.b=c` to `Map<String, Object>` will return a Map with the entry `{"a"={"b"="c"}}` whereas `[a.b]=c` will return a Map with the entry `{"a.b"="c"}`.



[[features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables]]
==== Binding From Environment Variables

Most operating systems impose strict rules around the names that can be used for environment variables.
For example, Linux shell variables can contain only letters (`a` to `z` or `A` to `Z`), numbers (`0` to `9`) or the underscore character (`_`).
By convention, Unix shell variables will also have their names in UPPERCASE.

Spring Boot's relaxed binding rules are, as much as possible, designed to be compatible with these naming restrictions.

To convert a property name in the canonical-form to an environment variable name you can follow these rules:

* Replace dots (`.`) with underscores (`_`).
* Remove any dashes (`-`).
* Convert to uppercase.

For example, the configuration property `spring.main.log-startup-info` would be an environment variable named `SPRING_MAIN_LOGSTARTUPINFO`.

Environment variables can also be used when binding to object lists.
To bind to a `List`, the element number should be surrounded with underscores in the variable name.

For example, the configuration property `my.service[0].other` would use an environment variable named `MY_SERVICE_0_OTHER`.



[[features.external-config.typesafe-configuration-properties.relaxed-binding.caching]]
==== Caching

Relaxed binding uses a cache to improve performance. By default, this caching is only applied to immutable property sources.
To customize this behavior, for example to enable caching for mutable property sources, use `ConfigurationPropertyCaching`.



[[features.external-config.typesafe-configuration-properties.merging-complex-types]]
=== Merging Complex Types

When lists are configured in more than one place, overriding works by replacing the entire list.

For example, assume a `MyPojo` object with `name` and `description` attributes that are `null` by default.
The following example exposes a list of `MyPojo` objects from `MyProperties`:

include-code::list/MyProperties[]

Consider the following configuration:

[configprops%novalidate,yaml]
----
my:
  list:
  - name: "my name"
    description: "my description"
---
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
----

If the `dev` profile is not active, `MyProperties.list` contains one `MyPojo` entry, as previously defined.
If the `dev` profile is enabled, however, the `list` _still_ contains only one entry (with a name of `my another name` and a description of `null`).
This configuration _does not_ add a second `MyPojo` instance to the list, and it does not merge the items.

When a `List` is specified in multiple profiles, the one with the highest priority (and only that one) is used.
Consider the following example:

[configprops%novalidate,yaml]
----
my:
  list:
  - name: "my name"
    description: "my description"
  - name: "another name"
    description: "another description"
---
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
----

In the preceding example, if the `dev` profile is active, `MyProperties.list` contains _one_ `MyPojo` entry (with a name of `my another name` and a description of `null`).
For YAML, both comma-separated lists and YAML lists can be used for completely overriding the contents of the list.

For `Map` properties, you can bind with property values drawn from multiple sources.
However, for the same property in multiple sources, the one with the highest priority is used.
The following example exposes a `Map<String, MyPojo>` from `MyProperties`:

include-code::map/MyProperties[]

Consider the following configuration:

[configprops%novalidate,yaml]
----
my:
  map:
    key1:
      name: "my name 1"
      description: "my description 1"
---
spring:
  config:
    activate:
      on-profile: "dev"
my:
  map:
    key1:
      name: "dev name 1"
    key2:
      name: "dev name 2"
      description: "dev description 2"
----

If the `dev` profile is not active, `MyProperties.map` contains one entry with key `key1` (with a name of `my name 1` and a description of `my description 1`).
If the `dev` profile is enabled, however, `map` contains two entries with keys `key1` (with a name of `dev name 1` and a description of `my description 1`) and `key2` (with a name of `dev name 2` and a description of `dev description 2`).

NOTE: The preceding merging rules apply to properties from all property sources, and not just files.



[[features.external-config.typesafe-configuration-properties.conversion]]
=== Properties Conversion

Spring Boot attempts to coerce the external application properties to the right type when it binds to the `@ConfigurationProperties` beans.
If you need custom type conversion, you can provide a `ConversionService` bean (with a bean named `conversionService`) or custom property editors (through a `CustomEditorConfigurer` bean) or custom `Converters` (with bean definitions annotated as `@ConfigurationPropertiesBinding`).

NOTE: As this bean is requested very early during the application lifecycle, make sure to limit the dependencies that your `ConversionService` is using.
Typically, any dependency that you require may not be fully initialized at creation time.
You may want to rename your custom `ConversionService` if it is not required for configuration keys coercion and only rely on custom converters qualified with `@ConfigurationPropertiesBinding`.



[[features.external-config.typesafe-configuration-properties.conversion.durations]]
==== Converting Durations

Spring Boot has dedicated support for expressing durations.
If you expose a `java.time.Duration` property, the following formats in application properties are available:

* A regular `long` representation (using milliseconds as the default unit unless a `@DurationUnit` has been specified)
* The standard ISO-8601 format {apiref-openjdk}/java.base/java/time/Duration.html#parse(java.lang.CharSequence)[used by `java.time.Duration`]
* A more readable format where the value and the unit are coupled (`10s` means 10 seconds)

Consider the following example:

include-code::javabeanbinding/MyProperties[]

To specify a session timeout of 30 seconds, `30`, `PT30S` and `30s` are all equivalent.
A read timeout of 500ms can be specified in any of the following form: `500`, `PT0.5S` and `500ms`.

You can also use any of the supported units.
These are:

* `ns` for nanoseconds
* `us` for microseconds
* `ms` for milliseconds
* `s` for seconds
* `m` for minutes
* `h` for hours
* `d` for days

The default unit is milliseconds and can be overridden using `@DurationUnit` as illustrated in the sample above.

If you prefer to use constructor binding, the same properties can be exposed, as shown in the following example:

include-code::constructorbinding/MyProperties[]


TIP: If you are upgrading a `Long` property, make sure to define the unit (using `@DurationUnit`) if it is not milliseconds.
Doing so gives a transparent upgrade path while supporting a much richer format.



[[features.external-config.typesafe-configuration-properties.conversion.periods]]
==== Converting Periods

In addition to durations, Spring Boot can also work with `java.time.Period` type.
The following formats can be used in application properties:

* An regular `int` representation (using days as the default unit unless a `@PeriodUnit` has been specified)
* The standard ISO-8601 format {apiref-openjdk}/java.base/java/time/Period.html#parse(java.lang.CharSequence)[used by `java.time.Period`]
* A simpler format where the value and the unit pairs are coupled (`1y3d` means 1 year and 3 days)

The following units are supported with the simple format:

* `y` for years
* `m` for months
* `w` for weeks
* `d` for days

NOTE: The `java.time.Period` type never actually stores the number of weeks, it is a shortcut that means "`7 days`".



[[features.external-config.typesafe-configuration-properties.conversion.data-sizes]]
==== Converting Data Sizes

Spring Framework has a `DataSize` value type that expresses a size in bytes.
If you expose a `DataSize` property, the following formats in application properties are available:

* A regular `long` representation (using bytes as the default unit unless a `@DataSizeUnit` has been specified)
* A more readable format where the value and the unit are coupled (`10MB` means 10 megabytes)

Consider the following example:

include-code::javabeanbinding/MyProperties[]

To specify a buffer size of 10 megabytes, `10` and `10MB` are equivalent.
A size threshold of 256 bytes can be specified as `256` or `256B`.

You can also use any of the supported units.
These are:

* `B` for bytes
* `KB` for kilobytes
* `MB` for megabytes
* `GB` for gigabytes
* `TB` for terabytes

The default unit is bytes and can be overridden using `@DataSizeUnit` as illustrated in the sample above.

If you prefer to use constructor binding, the same properties can be exposed, as shown in the following example:

include-code::constructorbinding/MyProperties[]

TIP: If you are upgrading a `Long` property, make sure to define the unit (using `@DataSizeUnit`) if it is not bytes.
Doing so gives a transparent upgrade path while supporting a much richer format.



[[features.external-config.typesafe-configuration-properties.validation]]
=== @ConfigurationProperties Validation

* requirements to validate
    ** `@ConfigurationProperties` + `@Validated` JSR-303 `jakarta.validation` | class
    ** JSR-303 implementation | classpath & constraint annotations | fields

include-code::MyProperties[]

* if you want to cascade validation | nested properties -> `@Valid` | associated field

include-code::nested/MyProperties[]

* steps to add a custom Spring `Validator`
    ** create a bean definition /
        *** called `configurationPropertiesValidator`
        *** declare `static`
            **** -> bean is created / WITHOUT having to instantiate the `@Configuration` class
            **** Reason: 🧠configuration properties validator is created very early | application's lifecycle 🧠

* `/actuator/configprops` or equivalent JMX endpoint
    ** == `spring-boot-actuator` 's endpoint / exposes all `@ConfigurationProperties` beans
    ** check xref:actuator/endpoints.adoc[Production ready features]


[[features.external-config.typesafe-configuration-properties.vs-value-annotation]]
=== @ConfigurationProperties vs. @Value

* `@Value` is a core container feature
* != features provide


[cols="4,2,2"]
|===
| Feature |`@ConfigurationProperties` |`@Value`

| xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding[Relaxed binding]
| Yes
| Limited (see xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.vs-value-annotation.note[note below])

| xref:specification:configuration-metadata/index.adoc[Meta-data support]
| Yes
| No

| `SpEL` evaluation
| No
| Yes
|===

[[features.external-config.typesafe-configuration-properties.vs-value-annotation.note]]
[NOTE]
====
If you do want to use `@Value`, we recommend that you refer to property names using their canonical form (kebab-case using only lowercase letters).
This will allow Spring Boot to use the same logic as it does when xref:features/external-config.adoc#features.external-config.typesafe-configuration-properties.relaxed-binding[relaxed binding] `@ConfigurationProperties`.

For example, `@Value("${demo.item-price}")` will pick up `demo.item-price` and `demo.itemPrice` forms from the `application.properties` file, as well as `DEMO_ITEMPRICE` from the system environment.
If you used `@Value("${demo.itemPrice}")` instead, `demo.item-price` and `DEMO_ITEMPRICE` would not be considered.
====

If you define a set of configuration keys for your own components, we recommend you group them in a POJO annotated with `@ConfigurationProperties`.
Doing so will provide you with structured, type-safe object that you can inject into your own beans.

`SpEL` expressions from  xref:features/external-config.adoc#features.external-config.files[application property files] are not processed at time of parsing these files and populating the environment.
However, it is possible to write a `SpEL` expression in `@Value`.
If the value of a property from an application property file is a `SpEL` expression, it will be evaluated when consumed through `@Value`.
